#ifndef LIST_LOADED_
#define LIST_LOADED_ 1

#include<stdio.h>

////////////////////////////////////////////////////////////////
// BOOLEANS (TRUE OR FALSE, EVALUATE TO 0 OR 1)
////////////////////////////////////////////////////////////////
typedef unsigned char bool;

#define TRUE 1
#define FALSE 0

////////////////////////////////////////////////////////////////
// SMALLINT (used as list lengths etc.)
////////////////////////////////////////////////////////////////
typedef long int smallint;

////////////////////////////////////////////////////////////////
// MEDINT (general purpose)
////////////////////////////////////////////////////////////////
typedef int medint;

////////////////////////////////////////////////////////////////
// SMALLINT/MEDINT TYPE MACROS
////////////////////////////////////////////////////////////////
#define min(a, b) ( ((a) < (b)) ? (a) : (b) )
#define max(a, b) ( ((a) < (b)) ? (b) : (a) )

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
// LISTS
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

typedef struct ln_t
{
    void *pData;
    struct ln_t *pNext;
    struct ln_t *pPrev;
} list_node, ln_t;

typedef bool (*compare_data_type)(void *, void *);
typedef void *(*copy_data_type)(void *);
typedef void (*destroy_data_type)(void *);
typedef void (*display_list_type)(void *);

typedef bool (*lessthan_order_type)(void *, void *);

typedef struct list
{
    list_node *pHead;
    list_node *pTail;
    smallint length;
    bool (*compare_data)(void *, void *);
    void *(*copy_data)(void *);
    void (*destroy_data)(void *);
    void (*display_list)(void *);
//    void *pData;
} list, l_t;

typedef l_t set, multiset, mlat;

typedef list_node set_node, multiset_node, mlat_node;

// mlat = maximal lattice

typedef struct line
{
    smallint length;
    smallint maxlength;
    medint *data;     // ARRAY
} line;



//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// LISTS : PUBLIC
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////         


extern list *list_new(bool (*compare_data)(void *, void *),
		      void *(*copy_data)(void *), void (*destroy_data)(void *),
		      void (*display_list)(void *));


#define list_compare_data(l, a, b) (((l)->compare_data)(a, b))

//////////////////////////////////////////////////////////////////////
// destroys list.
// uses destroy_data function to remove data from list
//////////////////////////////////////////////////////////////////////
extern void list_kill(list *pList);


//////////////////////////////////////////////////////////////////////
// destroys data from a node and remove node from list, concatenates
// stuff before and after.
//////////////////////////////////////////////////////////////////////
extern list_node *list_kill_node(list *pList, list_node *pListNode);

//////////////////////////////////////////////////////////////////////
// destroys everything except data. (targets of data pointers)
//////////////////////////////////////////////////////////////////////
extern void list_debone(list *pList);


//////////////////////////////////////////////////////////////////////
// returns a pointer to the node in the i'th place. i = 0 is the head,
// and i = length - 1 is the tail.
//////////////////////////////////////////////////////////////////////
extern list_node *list_get_node(list *pList, smallint i);


//////////////////////////////////////////////////////////////////////
// returns a copy of the list witht the i'th node removed.
// original list is unharmed.
//////////////////////////////////////////////////////////////////////
extern list *list_complement(list *pList, smallint i);

//////////////////////////////////////////////////////////////////////
// smallint list_length(list *pList); uses macro below
//////////////////////////////////////////////////////////////////////
#define list_length(l) ((l)->length)


//////////////////////////////////////////////////////////////////////
// list_node list_head(list *pList); return head node. uses macro below
//////////////////////////////////////////////////////////////////////
#define list_head(l) ((l)->pHead)


//////////////////////////////////////////////////////////////////////
// list_node list_tail(list *pList); return tail node. uses macro below
//////////////////////////////////////////////////////////////////////
#define list_tail(l) ((l)->pTail)


//////////////////////////////////////////////////////////////////////
// bool list_empty(list *pList); uses macro below. TRUE if list empty,
// FALSE if not.
//////////////////////////////////////////////////////////////////////
#define list_empty(l) ((list_length(l) == 0) ? TRUE : FALSE)


//////////////////////////////////////////////////////////////////////
// pushes data to the end of the list (after tail). Modifies list.
//////////////////////////////////////////////////////////////////////
extern void list_push(list *pList, void *pData);


//////////////////////////////////////////////////////////////////////
// pushes data after given node. Modifies list.
//////////////////////////////////////////////////////////////////////
extern void list_push_after(list *pList, list_node *pListNode, void *pData);


//////////////////////////////////////////////////////////////////////
// pushes data before given node. Modifies list.
//////////////////////////////////////////////////////////////////////
extern void list_push_before(list *pList, list_node *pListNode, void *pData);


//////////////////////////////////////////////////////////////////////
// pushes node to the end of the list (after tail). Modifies list.
//////////////////////////////////////////////////////////////////////
extern void list_push_node(list *pList, list_node *pNode);


//////////////////////////////////////////////////////////////////////
// pushes data to the beginning of the list (before head). Modifies list.
//////////////////////////////////////////////////////////////////////
extern void list_push_head(list *pList, void *pData);


//////////////////////////////////////////////////////////////////////
// modifies the given 2 lists, all further handling of the original
// data should be done via the output of this function.
/////////////////////////////////////////////////////////////////////
extern list *list_concat(list *pList1, list *pList2);


//////////////////////////////////////////////////////////////////////
// moves the head of list2 to the tail of list1. Returns TRUE if
// successful, or returns FALSE if list 2 is empty.
/////////////////////////////////////////////////////////////////////
extern bool list_transfer(list *pList1, list *pList2);


//////////////////////////////////////////////////////////////////////
// removes the node from the list, preserves the data. can
// be pushed to another list via list_push_node.
/////////////////////////////////////////////////////////////////////
extern void list_extract_node(list *pList, list_node *pListNode);


/////////////////////////////////////////////////////////////////////
// uses copy_data to copy list structure and data
/////////////////////////////////////////////////////////////////////
extern list *list_copy(list *pList);


/////////////////////////////////////////////////////////////////////
// copies list structure but not data. all targets of data pointers
// are the data of the original list.
/////////////////////////////////////////////////////////////////////
//extern list *list_copy_skeleton(list *pList);
//NOT DONE.


/////////////////////////////////////////////////////////////////////
// void list_display(list *pList); uses macro below
/////////////////////////////////////////////////////////////////////
#define list_display(l) ((l)->display_list(l))


/////////////////////////////////////////////////////////////////////
// starting at pList->pHead, checks condition and proceeds to do 
// action function if condition is false, then continues down list. 
// if condition is ever true, stops.
////////////////////////////////////////////////////////////////////
extern void list_while_do(list *pList, char (*Condition)(void *),
			  void (*ActionFunction_of_data)(void *));


/////////////////////////////////////////////////////////////////////
// performs actionfunction on data in each node
/////////////////////////////////////////////////////////////////////
extern void list_do_each(list *pList, 
			 void (*ActionFunction_of_data)(void *));


/////////////////////////////////////////////////////////////////////
// performs condition on data in each node. if true for a given node,
// node is killed using list_kill_node
/////////////////////////////////////////////////////////////////////
extern void list_kill_each_if(list *pList, bool (*condition)(void *));



/////////////////////////////////////////////////////////////////////
// returns true if condition is true for some member of list
// and false otherwise.
/////////////////////////////////////////////////////////////////////
extern bool list_true_for_some(list *pList, 
			       bool (*condition_on_data)(void *));



/////////////////////////////////////////////////////////////////////
// returns true if condition is true for all members of list
// and false otherwise.
/////////////////////////////////////////////////////////////////////
extern bool list_true_for_all(list *pList, 
			      bool (*condition_on_data)(void *));



/////////////////////////////////////////////////////////////////////
// pushes data to list so that list is ordered with smaller items
// near the head and larger near the tail.
/////////////////////////////////////////////////////////////////////
extern void list_ordered_push(list *pList, void *pData, 
			      lessthan_order_type less_than);


///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
// LIST NODES
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

#define list_node_next(ln) ((ln)->pNext)
#define list_node_prev(ln) ((ln)->pPrev)
#define list_node_data(ln) ((ln)->pData)

#define list_node_is_head(ln) ((ln)->pPrev == NULL) ? TRUE : FALSE
#define list_node_is_tail(ln) ((ln)->pNext == NULL) ? TRUE : FALSE

#define list_node_kill list_kill_node

//////////////////////////////////////////////////////////////////////
// META-LISTS :  THESE ARE LISTS WHOSE
// DATA POINTER TARGETS ARE THEMSELVES LISTS. WE HAVE A COUPLE OF
// CHOICES OF HOW WE IMPLEMENT THESE.
//
// CONVENTIONS : 
//    -compare is set_equals
//    -display is list displays seperated by new lines.
//
// CHOICES :
//    1. TRUE METALISTS (metalist)
//          -copy does list_copy
//          -destroy does list_kill
//
//    2. SHELL METALISTS (metalist_shell)
//          -copy does list_skeleton_copy
//          -destroy does list_debone
//////////////////////////////////////////////////////////////////////

// true metalist:
extern list *metalist_new();

// inserts new list so that lists will be ordered by length from short
// to long.
extern void metalist_ordered_push(list *pMetaList, void *pList);


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// SETS : PUBLIC
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////         


//////////////////////////////////////////////////////////////////////
// checks if data is an element of the set
//////////////////////////////////////////////////////////////////////
extern bool set_is_member(set *pSet, void *pData);


//////////////////////////////////////////////////////////////////////
// checks if set1 is contained in set2
//////////////////////////////////////////////////////////////////////
extern bool set_is_subset(set *pSet1, set *pSet2);


//////////////////////////////////////////////////////////////////////
// checks if set1 = set2
//////////////////////////////////////////////////////////////////////
extern bool set_equals(set *pSet1, set *pSet2);


//////////////////////////////////////////////////////////////////////
// checks if data in already in set using compare_data. If it isn't,
// pushes data to the end of the set (after tail). Modifies list.
// returns a TRUE if successful (data pushed) or FALSE if not.
//////////////////////////////////////////////////////////////////////
extern bool set_push(set *pSet, void *pData);


/////////////////////////////////////////////////////////////////////
// pushes data to set so that set is ordered with smaller items
// near the head and larger near the tail. checks if data is already
// in set as above.
/////////////////////////////////////////////////////////////////////
extern bool set_ordered_push(set *pSet, void *pData, 
			     lessthan_order_type less_than);




//////////////////////////////////////////////////////////////////////
// returns the complement of the subset in the given set.
// does not strictly require containment. (gives set difference)
// removes all occurences of elements of the subset
//////////////////////////////////////////////////////////////////////
extern set *set_subset_complement(set *pSet, set *pSubset);


//////////////////////////////////////////////////////////////////////
// returns an empty set with the same methods as original set.
//////////////////////////////////////////////////////////////////////
extern set *set_empty_subset(set *pSet);


//////////////////////////////////////////////////////////////////////
// removes all occurences of an element from a set
//////////////////////////////////////////////////////////////////////
extern void set_remove_element(set *pSet, void *pElementData);


/////////////////////////////////////////////////////////////////////
// creates the powerset of a given set - this is a metaset object
// eq = set_eq.
/////////////////////////////////////////////////////////////////////
extern set *set_powerset(set *pSet);


/////////////////////////////////////////////////////////////////////
// creates the set of subsets of order n.
/////////////////////////////////////////////////////////////////////
extern set *set_subsets(set *pSet, smallint n);


//////////////////////////////////////////////////////////////////////
// other methods are implemented from list methods as definitions.
//////////////////////////////////////////////////////////////////////
#define set_new list_new
#define set_kill list_kill
#define set_kill_node list_kill_node
#define set_debone list_debone
#define set_length list_length
#define set_empty list_empty
#define set_push_head list_push_head
#define set_concat list_concat
#define set_copy list_copy
//#define set_copy_skeleton list_copy_skeleton
#define set_display list_display
#define set_force_transfer list_transfer
#define set_while_do list_while_do
#define set_do_each list_do_each
#define set_head list_head
#define set_complement list_complement
#define set_get_node list_get_node
#define set_force_push list_push
#define set_compare_data list_compare_data
#define set_true_for_some list_true_for_some
#define set_true_for_all list_true_for_all
#define set_kill_each_if list_kill_each_if
#define metaset_new metalist_new


////////////////////////////////////////////////////////////////////////
// sets the subset argument to the first element of mlat_generate in the
// next section below. returns a 1 if successful, or a 0 of the mlat is
// empty.
////////////////////////////////////////////////////////////////////////
extern bool set_maximal_subset(set **ppSubset, set *pSet,
			       bool (*condition)(set *pSubset, void *pData), 
			       void *pData, int limit);


///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
// SET NODES
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

#define set_node_next list_node_next
#define set_node_prev list_node_prev
#define set_node_data list_node_data
#define set_node_is_head list_node_is_head
#define set_node_is_tail list_node_is_tail
#define set_node_kill set_kill_node

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// MAXIMAL LATTICES (MLATs)  
// THESE ARE (TRUE) META-SETS (using metalist def) 
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

#define mlat_new metalist_new
#define mlat_is_member set_is_member
#define mlat_is_sublat set_is_subset
#define mlat_equals set_equals
#define mlat_kill set_kill
#define mlat_kill_node set_kill_node
#define mlat_debone set_debone
#define mlat_length set_length
#define mlat_empty set_empty
#define mlat_concat set_concat
#define mlat_copy set_copy
#define mlat_copy_skeleton set_copy_skeleton
#define mlat_display set_display
#define mlat_while_do set_while_do
#define mlat_do_each set_do_each
#define mlat_head set_head
#define mlat_true_for_some set_true_for_some
#define mlat_true_for_all set_true_for_all
#define mlat_kill_each_if set_kill_each_if
#define mlat_get_node set_get_node
#define mlat_force_push list_push

//////////////////////////////////////////////////////////////////////
// checks if set is a subset of a member of the given lattice
//////////////////////////////////////////////////////////////////////
extern bool mlat_is_dominated(mlat *pMlat, set *pData);


//////////////////////////////////////////////////////////////////////
// mlat_push will only add a set in if it is not dominated by
// the given lattice. returns TRUE is push is successful (data not
// dominated) and FALSE otherwise.
//////////////////////////////////////////////////////////////////////
extern bool mlat_push(mlat *pMlat, set *pData);



//////////////////////////////////////////////////////////////////////
// creates a maximal lattice of all the subsets of the given set
// having a specified condition satisfied
//////////////////////////////////////////////////////////////////////
extern mlat *mlat_generate(set *pSet, void *pData,
			   bool (*condition)(set *pSubset, void *pData));



//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// MULTISETS : PUBLIC
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////         
// a multiset is a set where each memeber may be included some positive
// number of times.

//////////////////////////////////////////////////////////////////////
// checks if data is an element of the multiset. returns the
// multiplicity of the inclusion (0 if not a member)
//////////////////////////////////////////////////////////////////////
extern medint multiset_is_member(multiset *pMultiset, void *pData);


//////////////////////////////////////////////////////////////////////
// checks if multiset1 is contained in multiset2
//////////////////////////////////////////////////////////////////////
extern bool multiset_is_submultiset(multiset *pMultiset1, 
				    multiset *pMultiset2);


//////////////////////////////////////////////////////////////////////
// checks if multiset1 = multiset2
//////////////////////////////////////////////////////////////////////
extern bool multiset_equals(multiset *pMultiset1, multiset *pMultiset2);



//////////////////////////////////////////////////////////////////////
// returns the complement of the submultiset in the given multiset.
// does not strictly require containment. (gives multiset difference)
// removes occurences of elements of the submultiset up to the
// maximally occuring multiplicity.
//////////////////////////////////////////////////////////////////////
extern multiset *multiset_submultiset_complement(multiset *pMultiset, 
						 multiset *pSubmultiset);


//////////////////////////////////////////////////////////////////////
// removes one occurence of an element from a set
//////////////////////////////////////////////////////////////////////
extern void multiset_remove_element(multiset *pMultiset, 
				    void *pElementData);



//////////////////////////////////////////////////////////////////////
// other methods are implemented from list methods as definitions.
//////////////////////////////////////////////////////////////////////
#define multiset_push list_push
#define multiset_new list_new
#define multiset_kill list_kill
#define multiset_kill_node list_kill_node
#define multiset_debone list_debone
#define multiset_length list_length
#define multiset_empty list_empty
#define multiset_push_head list_push_head
#define multiset_concat list_concat
#define multiset_copy list_copy
//#define multiset_copy_skeleton list_copy_skeleton
#define multiset_display list_display
#define multiset_while_do list_while_do
#define multiset_do_each list_do_each

#define multiset_transfer set_force_transfer
#define multiset_empty_submultiset set_empty_subset
#define multiset_head list_head
#define multiset_node_kill list_node_kill
#define multiset_node_next list_node_next
#define multiset_node_data list_node_data
#define multiset_compare_data list_compare_data



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// METAMULTISETS : SETS OF MULTISETS
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// these are implemented as metasets, except uses multiset equals instead
// of set equals.
/////////////////////////////////////////////////////////////////////////

extern set *metamultiset_new();

extern set *multiset_powerset(multiset *pMultiset);

// generates all multisubsets of given size.
extern set *multiset_subsets(multiset *pMultiset, smallint size);




/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// LINE : PUBLIC
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
// returns a new list of the given length
/////////////////////////////////////////////////////////////////////////
extern line *line_new(smallint length);


extern void line_kill(line *pLine);


/////////////////////////////////////////////////////////////////////////
// smallint line_length(line *pLine);  uses macro below
/////////////////////////////////////////////////////////////////////////

#define line_length(l) ((l)->length)

#define line_maxlength(l) ((l)->maxlength)

/////////////////////////////////////////////////////////////////////////
// returns i'th data entry, or 0 and an error message if i >= length
//  medint line_data(line *pLine, smallint i); uses macro below
/////////////////////////////////////////////////////////////////////////
#define line_data(l, i) (i < line_length(l)) ? \
((l)->data)[i] : (__line_data_error_())

/////////////////////////////////////////////////////////////////////////
// pushes data to the end of list.
/////////////////////////////////////////////////////////////////////////
extern void line_push(line *pLine, medint d);


/////////////////////////////////////////////////////////////////////////
// simply sets the length to 0. this causes future pushed data to
// overwrite old data.
// void line_clear(line *pLine); uses macro below
/////////////////////////////////////////////////////////////////////////
#define line_clear(l) ((l)->length = 0)


/////////////////////////////////////////////////////////////////////////
// displays entries in line seperated by spaces. No space at end, no
// newlines.
/////////////////////////////////////////////////////////////////////////
extern void line_display(line *pLine);


/////////////////////////////////////////////////////////////////////////
// displays to file
/////////////////////////////////////////////////////////////////////////
extern void line_display_file(FILE *outfile, line *pLine);


/////////////////////////////////////////////////////////////////
// MEDINT LISTS
/////////////////////////////////////////////////////////////////

extern list *medint_list_new();

extern medint medint_list_sum(list *pList);

extern medint *medint_new();

extern void medint_list_errdisplay(list *pList);

extern list *medint_list_read(char *s);

#define medint_compare(pa, pb) \
  (medint_compare_void((medint *) (pa), (medint *) (pb)))

#define medint_copy(pa) (medint_copy_void((medint *) (pa)))

#define medint_kill(pa) (medint_destroy((medint *) (pa)))

#endif
